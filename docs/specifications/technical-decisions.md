# 技術的意思決定記録 (ADR: Architecture Decision Records)

このドキュメントは、Visual Prompt Builderプロジェクトにおける重要な技術的意思決定とその理由を記録しています。

## 目次

1. [アーキテクチャ決定](#アーキテクチャ決定)
2. [フレームワーク・ライブラリ選定](#フレームワークライブラリ選定)
3. [開発プロセス決定](#開発プロセス決定)
4. [設計パターン決定](#設計パターン決定)

## アーキテクチャ決定

### ADR-001: Monorepo構造の採用

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- フロントエンド、バックエンド、共有コードを一つのリポジトリで管理する必要がある
- 型定義を共有して型安全性を確保したい
- 依存関係を明確に管理したい

**決定**:
npm workspacesを使用したMonorepo構造を採用する

```
visual-prompt-builder/
├── frontend/     # Reactアプリケーション
├── workers/      # Cloudflare Workers
└── shared/       # 共有型定義・定数
```

**理由**:
1. 型定義の一元管理により、フロントエンド・バックエンド間の不整合を防げる
2. 共通のビルド・テスト・デプロイプロセスを適用できる
3. コードの再利用性が高まる
4. npm workspacesはシンプルで学習コストが低い

**影響**:
- ✅ 型安全性の向上
- ✅ DRY原則の実現
- ❌ 初期設定の複雑さ
- ❌ 小規模プロジェクトにはオーバーエンジニアリングの可能性

**教訓** (2025-01-25更新):
- 実際に型定義の共有は非常に有効だった
- ただし、初期設定で`npm install`を忘れがちなので注意が必要

### ADR-002: Cloudflare Workers/Pagesの採用

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- グローバルに低遅延でサービスを提供したい
- サーバー管理のコストを削減したい
- スケーラビリティを確保したい

**決定**:
バックエンドにCloudflare Workers、フロントエンドホスティングにCloudflare Pagesを採用

**理由**:
1. エッジコンピューティングによる低遅延
2. サーバーレスで運用コスト削減
3. 自動スケーリング
4. DDoS保護などセキュリティ機能が標準装備

**影響**:
- ✅ グローバル配信が容易
- ✅ 運用コスト削減
- ❌ ローカル開発環境の制約
- ❌ KV Namespaceなど独自APIの学習コスト

## フレームワーク・ライブラリ選定

### ADR-003: React + TypeScript + Viteの採用

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- モダンなSPAを構築したい
- 型安全性を確保したい
- 開発体験を向上させたい

**決定**:
- UI: React 18
- 言語: TypeScript
- ビルドツール: Vite

**理由**:
1. **React**: 豊富なエコシステム、採用実績
2. **TypeScript**: 型安全性、IDE支援、バグの早期発見
3. **Vite**: 高速なHMR、ESMベース、設定がシンプル

**影響**:
- ✅ 優れた開発体験（特にViteのHMR）
- ✅ 型によるバグ防止
- ❌ TypeScriptの学習コスト
- ❌ 設定ファイルの増加

**教訓** (2025-01-25更新):
- Viteは本当に速い。webpackと比較して開発効率が大幅に向上
- TypeScriptは初期の型定義に時間がかかるが、長期的には時間短縮になる

### ADR-004: Zustandによる状態管理

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- グローバル状態管理が必要
- Reduxは過度に複雑
- TypeScript対応が必要

**決定**:
状態管理にZustandを採用

```typescript
// シンプルなストア定義
const useStore = create<StoreState>((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));
```

**理由**:
1. APIがシンプルで学習コストが低い
2. TypeScript対応が優秀
3. Redux DevToolsが使える
4. バンドルサイズが小さい（8KB）

**影響**:
- ✅ ボイラープレート削減
- ✅ 開発速度向上
- ❌ 大規模化時のパターンが確立されていない
- ❌ Reduxほどエコシステムが豊富でない

### ADR-005: Tailwind CSSの採用

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- 一貫性のあるデザインシステムが必要
- CSSの命名に悩みたくない
- レスポンシブデザインを効率的に実装したい

**決定**:
スタイリングにTailwind CSSを採用

**理由**:
1. ユーティリティファーストで開発速度向上
2. デザインの一貫性確保
3. レスポンシブデザインが簡単
4. PurgeCSSによる最適化

**影響**:
- ✅ スタイリングの高速化
- ✅ デザインの一貫性
- ❌ HTMLが冗長になる
- ❌ 学習曲線がある

**教訓** (2025-01-25更新):
- クラス名は確かに長くなるが、慣れると非常に効率的
- VSCode拡張機能（Tailwind CSS IntelliSense）は必須

## 開発プロセス決定

### ADR-006: Issue駆動開発

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- 180個のタスクを効率的に管理したい
- 進捗を可視化したい
- 後から作業内容を追跡したい

**決定**:
GitHub Issuesを使用したIssue駆動開発を採用
- 1 Issue = 1-2時間の作業量
- ラベルによる分類
- マイルストーンによるフェーズ管理

**理由**:
1. 進捗の可視化
2. タスクの粒度管理
3. コミットとの紐付け
4. 後からの追跡が容易

**影響**:
- ✅ 進捗管理の改善
- ✅ モチベーション維持
- ❌ Issue作成のオーバーヘッド
- ❌ 細かすぎるタスク分割の危険性

### ADR-007: 実装記録と感情ログ

**日付**: 2024-12-25

**ステータス**: 採用

**コンテキスト**:
- 開発過程を記録して改善につなげたい
- エンジニアの本音を収集してマネジメント改善したい
- 同じ失敗を繰り返したくない

**決定**:
- 実装記録ログの義務化
- 感情ログ（本音）の記録推奨

**理由**:
1. 問題の早期発見
2. プロセス改善のデータ収集
3. ナレッジの蓄積
4. 心理的安全性の向上

**影響**:
- ✅ 問題点の可視化
- ✅ 継続的改善
- ❌ 記録の手間
- ❌ 本音を書くことへの抵抗感

**教訓** (2025-01-25更新):
- 感情ログは非常に有効。問題の本質が見える
- ただし外部公開は厳禁

## 設計パターン決定

### ADR-008: 型定義の一元管理

**日付**: 2025-01-25

**ステータス**: 採用（改訂）

**コンテキスト**:
- name/nameEn/displayNameなど似た属性が混在
- マスターデータと選択データで型が異なる
- 型の不整合によるランタイムエラーが発生

**決定**:
- マスターデータは`name`（日本語）と`nameEn`（英語）を持つ
- 選択データは`displayName`と`predefinedId`を持つ
- `predefinedId`経由でマスターデータにアクセスする設計

```typescript
// マスターデータ
interface CategoryMaster {
  id: string;
  name: string;
  nameEn: string;
}

// 選択データ
interface Selection {
  predefinedId?: string;
  customText?: string;
  displayName: string;
}

// アクセスパターン
const name = selection.customText || 
  (selection.predefinedId && getMasterData(selection.predefinedId)?.name) ||
  selection.displayName;
```

**理由**:
1. 役割の明確な分離
2. 将来の拡張性（他言語追加など）
3. カスタム入力との統一的な扱い

**影響**:
- ✅ 型安全性の向上
- ✅ 拡張性の確保
- ❌ 間接的なアクセスによる複雑さ

### ADR-009: コンポーネント設計原則

**日付**: 2025-01-25

**ステータス**: 採用

**コンテキスト**:
- 再利用可能なコンポーネントが必要
- アクセシビリティ要件を満たす必要
- 保守性を確保したい

**決定**:
以下の原則に従ったコンポーネント設計
1. 単一責任の原則
2. Props型の明確な定義
3. アクセシビリティファースト
4. Composition over Inheritance

**実装例**:
```typescript
interface ButtonProps {
  variant: 'primary' | 'secondary';
  size: 'sm' | 'md' | 'lg';
  onClick: () => void;
  children: React.ReactNode;
  disabled?: boolean;
  'aria-label'?: string;
}
```

**理由**:
1. テスタビリティの向上
2. 再利用性の確保
3. アクセシビリティ要件の達成

**影響**:
- ✅ コンポーネントの品質向上
- ✅ 開発効率の向上
- ❌ 初期設計に時間がかかる

## 今後の検討事項

### 検討中の技術決定

1. **E2Eテストフレームワーク**
   - Playwright vs Cypress
   - 決定保留中

2. **国際化（i18n）ライブラリ**
   - 現在は独自実装
   - react-i18next検討中

3. **エラー監視サービス**
   - Sentry vs Rollbar
   - 本番運用開始時に決定予定

### 見直しが必要な決定

1. **useKeyboardShortcuts実装**
   - 現在DOM直接操作
   - React wayに修正予定

2. **Dynamic Import戦略**
   - default export vs named export
   - 統一方針の策定が必要

## まとめ

これらの技術的意思決定は、プロジェクトの要件と制約を考慮して行われました。決定は固定的なものではなく、新しい知見や要件の変化に応じて見直されるべきものです。

重要なのは、なぜその決定をしたのかを記録し、後から振り返れるようにすることです。これにより、同じ議論の繰り返しを避け、新しいメンバーへの知識伝達もスムーズになります。